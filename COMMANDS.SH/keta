#! /bin/sh

# designed by Nobuaki Tounaka
# written by 321516

# print the usage and exit
print_usage_and_exit () {
  cat <<-__USAGE 1>&2
	Usage   : ${0##*/} n1 n2 .. <filename>
	        : ${0##*/} -v <filename>
	        : ${0##*/} [--] <filename>
	Version : Fri Dec  4 19:03:11 JST 2015
	        : Open usp Tukubai (POSIX.1 Bourne Shell/POSIX.1 commands/UTF-8)
__USAGE
  exit 1
}
# the alternative of the "mktemp -t"
mktempf0() {
  # --- parameters, etc. ---------------------------------------------
  num_of_digits=16  # Length of Random String
  n=10              # Max Times of Retrying
  chrs='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_'
                    # Available letters
  LF=$(printf '\\\n_');LF=${LF%_}
  # --- call built-in mktemp if exists -------------------------------
  type mktemp >/dev/null 2>&1 && {
    mktemp -t tmp.${0##*/}.$$.XXXXXXXXXXXXXXXX
    return $?
  }
  # --- set the temporary directory ----------------------------------
  Dir_tmp=$(set | grep -q ^TMPDIR= | sed 's/^[^=]\{1,\}=//');
  case "$Dir_tmp" in
    '') Dir_tmp='/tmp'      ;;
    /)  Dir_tmp=''          ;;
    *)  Dir_tmp=${Dir_tmp%/};;
  esac
  # --- mktemp loop --------------------------------------------------
  while [ $n -ge 0 ]; do
    # --- Generate Ramdom string -------------------------------------
    # calculate the number of words which required
    nw=$(echo "${num_of_digits}*l(${#chrs})/11.09+1" | # 11.09=ln(65536)
         bc -l                                       |
         sed 's/\..*$//'                             )
    # make a random hexadecimal digit
    if [ -c /dev/urandom ]; then
      hstr=$(dd if=/dev/urandom bs=2 count=$nw 2>/dev/null |
             od -A n -t x2 -v                              |
             tr 'abcdef ' 'ABCDEF\n'                       |
             tr -Cd 0123456789ABCDEF                       )
    else
      hstr=$( (ps -Ao pid,etime,pcpu,vsz; date)         |
             od -t d4 -A n -v                           |
             sed 's/[^0-9]\{1,\}/'"$LF"'/g'             |
             grep '[0-9]'                               |
             tail -n 42                                 |
             sed 's/.*\(.\{8\}\)$/\1/g'                 |
             awk 'BEGIN{a=-2147483648;}                 #
                       {a+=$1;        }                 #
                  END  {                                #
                    srand(a);                           #
                    for(i=0;i<'$nw';i++){               #
                      printf("%02X",int(rand()*65536)); #
                    }                                   #
                  }'                                    )
    fi
    # make a random string from the hexadecimal digit
    s=$(echo "obase=${#chrs};ibase=16;$hstr"                     |
        bc                                                       |
        tr -d '\\\n'                                             |
        tr ' ' '\n'                                              |
        awk 'BEGIN  {for(i=1;i<'$num_of_digits';i++){print 0;}}  #
             /[0-9]/{print;                                   }' |
        awk 'BEGIN  {ORS="";                                     #
                     s="'"$chrs"'";                              #
                     for(i=0;i<length(s);i++){                   #
                       c[i]=substr(s,i+1,1);                     #
                     }                        }                  #
             /[0-9]/{print c[$0*1];           }'                 |
        tail -c $num_of_digits                                   )
    # --- Making the file path ---------------------------------------
    Path_target="${Dir_tmp}/tmp.${0##*/}.$$.$s"
    # --- Making the file --------------------------------------------
    (set -C; umask 177; : > "$Path_target") 2>/dev/null || {
      [ -f "$Path_target" ] && { n=$((n-1)); continue; }
      n=-1; break;
    }
    break
  done
  # --- print error message when failed to make a file ---------------
  case "$n" in -1) return 1;; esac
  # --- print the path of the file -----------------------------------
  printf '%s\n' "$Path_target"
  # --- return successfully ------------------------------------------
  return 0
}
# decide whether to use the alternative length of AWK or not
if awk 'BEGIN{a[1]=1;b=length(a)}' 2>/dev/null; then
  arlen='length'
else
  arlen='arlen'
fi


# initialize
set -u
umask 0022
PATH='/usr/bin:/bin'
IFS=$(printf ' \t\n_'); IFS=${IFS%_}
export IFS LANG=C LC_ALL=C PATH
widthes=''
left_justification=0
verbose=0
readonce=0
file=''
tmpfile=''
mode=0 # 0 ... count the max-widthes of all fields & auto-right-justification
       # 1 ... right-justification with the specified widthes
       # 2 ... count the max-widthes of all fields & auto-left-justification
       # 3 ... count the max-widthes of all fields & print them

# parse the arguments
case "${1:-}" in
  --)
    left_justification=1
    mode=2
    shift
    lastarg=${1:-}
    ;;
  -v)
    verbose=1
    mode=3
    shift
    lastarg=${1:-}
    ;;
esac
if [ $mode -eq 0 ]; then
  while [ $# -gt 0 ]; do
    test=$(printf '%s\n' "$1" | grep -E '^-?[0-9]+(x([0-9]+|NF(-[0-9]+)?))?$')
    if [ -n "$test" ]; then
      mode=1
      widthes="$widthes ${test#_}"
      shift
    else
      break
    fi
  done
  widthes=${widthes# }
fi
if [ $# -gt 1 ]; then
  print_usage_and_exit
elif [ -z "${1:-}" ]; then
  file='-'
elif [ \( -f "$1" \) -o \( -c "$1" \) -o \( -p "$1" \) -o \
       \( "_$1" = '_-' \)                                 ]; then
  file="$1"
else
  print_usage_and_exit
fi
if [ \( ! -r "$file" \) -a \( "_$file" != '_-' \) ]; then
  printf '%s: Cannot open the file\n' "${0##*/}" 1>&2
  exit 1
fi


# create a temporary file if the file is the stdin and mode==0|2
if [ \( "_$file" = '_-'               \) -o \
     \( "_$file" = '_/dev/stdin'      \) -o \
     \( "_$file" = '_/dev/fd/0'       \) -o \
     \( "_$file" = '_/proc/self/fd/0' \) -o ]
then
  readonce=1
elif [ \( -c "$file"                  \) -o \
       \( -p "$file"                  \)    ]
then
  readonce=2
fi
if [ \( $readonce -ne 0 \) -a \( \( $mode -eq 0 \) -o \( $mode -eq 2 \) \) ]
then
  tmpfile=$(mktempf0)
  if [ $? -eq 0 ]; then
    trap "rm -f $tmpfile; exit" EXIT HUP INT QUIT PIPE ALRM TERM
    case $readonce in
      1) cat         > "$tmpfile";;
      2) cat "$file" > "$tmpfile";;
    esac
    file=$tmpfile
  else
    printf '%s: Cannot create a temporary file\n' "${0##*/}" 1>&2
    exit 1
  fi
fi
case "$file" in ''|-|/*|./*|../*) :;; *) file="./$file";; esac


# awkcode : get the length of the UTF-8 string (it is not a byte number)
awkcode_func_utf8strlen='
# strlen for UTF-8 (main)
function utf8strlen(str, len,i,l1,l2,l3) {
  len = 0;
  for (i = 1; i <= length(str); i++) {
    len++;
    l1=substr(str, i, 1);
    if        (l1 =="\010") {len-=2;continue;
    } else if (l1 < "\200") {       continue;
    } else if (l1 < "\300") {len--; continue;
    } else if (l1 < "\340") {i++;
    } else if (l1 < "\360") {
      if (l1 == "\357") {
        l2 = substr(str, i+1, 1);
        if (l2 == "\275") {
          l3 = substr(str, i+2, 1);
          if ((l3 >= "\240") && (l3 < "\300")) {len--;}
        } else if (l2 == "\276") {
          l3 = substr(str, i+2, 1);
          if ((l3 >= "\200") && (l3 < "\240")) {len--;}
        }
      }
      i += 2;
    } else if (l1 < "\370") {i += 3;
    } else if (l1 < "\374") {i += 4;
    } else if (l1 < "\376") {i += 5;
    } else                  {len-- ; continue;}
    len++;
  }
  return len;
}
'


# count the max-widthes of the fields
if [ \( $mode -eq 0 \) -o \( $mode -eq 2 \) -o \( $mode -eq 3 \) ]; then

awkcode_main_width_counter='
BEGIN {
  max_nf = 0;
}

{
  if (NF >= max_nf) {
    for (i = 1; i <= max_nf; i++) {
      width = utf8strlen($i);
      if (width > max_width[i]) {
        max_width[i] = width;
      }
    }
    for (i = max_nf + 1; i <= NF; i++) {
      width = utf8strlen($i);
      max_width[i] = width;
    }
    max_nf = NF;
  } else {
    for (i = 1; i <= NF; i++) {
      width = utf8strlen($i);
      if (width > max_width[i]) {
        max_width[i] = width;
      }
    }
  }
}

END {
  widthes = "";
  for (i = 1; i <= max_nf; i++) {
    widthes = widthes max_width[i] FS;
  }
  print substr(widthes, 1, length(widthes) - 1);
}
'
widthes=$(awk "$awkcode_main_width_counter$awkcode_func_utf8strlen" "$file")

fi


# print the max-widthes and exit normally when mode=3("-v" option)
if [ $mode -eq 3 ]; then
  echo "$widthes"
  exit 0
fi


# *(-1) all the width numbers for left-justification when mode=2("--" option)
if [ $mode -eq 2 ]; then
  widthes=$(echo "$widthes" | sed 's/\([0-9]\{1,\}\)/-\1/g')
fi


# justificate the all fields
if [ \( $mode -eq 0 \) -o \( $mode -eq 1 \) -o \( $mode -eq 2 \) ]; then

awkcode_main_justificator='
# the alternative length function for array variable
function arlen(ar,i,l){for(i in ar){l++;}return l;}

BEGIN {
  split(widthes_str, width_str);
  varriable_widthes = (match(widthes_str, /NF/)) ? 1 : 0;
  if (!varriable_widthes) {
    decide_widthes();
  }
  last_nf = 0;
}

{
  # re-decide width numbers when the number of the NF has changed
  if (varriable_widthes && (NF != last_nf)) {
    decide_widthes();
    last_nf = NF;
  }
  # justificate the fields and concatinate them
  line = "";
  for (i = 1; i <= NF; i++) {
    size = utf8strlen($i);
    if ((i in width) && (width[i] > size)) {
      # right-justification
      padding = "";
      if (width[i] - size > 0) {
        padding = sprintf("%0" (width[i] - size) "d", 0);
        gsub("0", " ", padding);
      }
      line = line padding $i FS;
    } else if ((i in width) && (-width[i] > size)) {
      # left-justification
      padding = "";
      if (-width[i] - size > 0) {
        padding = sprintf("%0" (-width[i] - size) "d", 0);
        gsub("0", " ", padding);
      }
      line = line $i padding FS;
    } else {
      # non-justification
      line = line $i FS;
    }
  }
  print substr(line, 1, length(line)-length(FS));
}

function decide_widthes(   mode,i,j,k,n,s) {
  split("", width);
  j = 0;
  for (i = 1; i <= '$arlen'(width_str); i++) {
    if (match(width_str[i], /^-?[0-9]+$/)) {
      j++;
      width[j] = width_str[i];
      continue;
    }
    if (match(width_str[i], /^-?[0-9]+x[0-9]+$/)) {
      mode = 1;
    } else if (match(width_str[i], /^-?[0-9]+xNF$/)) {
      mode = 2;
    } else if (match(width_str[i], /^-?[0-9]+xNF-[0-9]+$/)) {
      mode = 3;
    } else {
      continue;
    }
    match(width_str[i], /^-?[0-9]+/);
    s = substr(width_str[i], RSTART, RLENGTH);
    if (mode == 1) {
      match(width_str[i], /[0-9]+$/);
      n = substr(width_str[i], RSTART, RLENGTH) + 0;
      for (k = 0; k < n; k++) {
        j++;
        width[j] = s;
      }
    } else if (mode == 2) {
      n = NF;
      for (k = 0; k < n; k++) {
        j++;
        width[j] = s;
      }
    } else if (mode == 3) {
      match(width_str[i], /[0-9]+$/);
      n = NF - substr(width_str[i], RSTART, RLENGTH);
      for (k = 0; k < n; k++) {
        j++;
        width[j] = s;
      }
    }
  }
}
'
if [ -z "$tmpfile" ]; then
  exec awk -v "widthes_str=$widthes"                                       \
              "$awkcode_main_justificator$awkcode_func_utf8strlen" "$file"
else
# (commands should not be run with "exec" because of having to remove tempfile)
       awk -v "widthes_str=$widthes"                                       \
              "$awkcode_main_justificator$awkcode_func_utf8strlen" "$file"
fi

fi
